<!DOCTYPE html>
<html>
  <head>
    <title>Maze Fun</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
    <style>
      body {
        text-align: center;
      }

      .open {
        display: block;
      }

      .closed {
        display: none;
      }
    </style>
    <script>
      let cols, rows;
      const w = 20;
      let grid = [];
      let current;
      let stack = [];
      let solving = false;
      let solutionPath = [];
      let startCell, endCell;
      let visitCount = 0;
      let changedCells = [];

      function setup() {
        createCanvas(windowWidth, windowHeight);
        frameRate(10);
        cols = floor(width / w);
        rows = floor(height / w);
        background(255);
        initializeMaze();
      }

      function addChangedIf(cell) {
        if (changedCells.indexOf(cell) == -1) {
          changedCells.push(cell);
        }
      }

      function draw() {
        if (!solving) {
          current.visited = true;
          current.visitOrder = visitCount++;
          addChangedIf(current);
          let next = current.checkNeighbors();
          if (next) {
            addChangedIf(next);
            next.visited = true;
            stack.push(current);
            removeWalls(current, next);
            current = next;
          } else if (stack.length > 0) {
            current = stack.pop();
            addChangedIf(current);
          } else {
            solving = true;
            startCell = grid[0];
            endCell = grid[grid.length - 1];
            for (let i = 0; i < grid.length; i++) {
              grid[i].solved = false;
            }
            startCell.solve();
          }
        } else {
          updateSolutionPath();
        }

        if (current) current.highlight();
        for (let cell of changedCells) {
          cell.show();
        }
        if (solving) {
          changedCells = changedCells.slice(-1);
        } else if (changedCells.length > 30) {
          changedCells = changedCells.slice(-25);
        }
      }

      function updateSolutionPath() {
        if (solutionPath.length > 0) {
          let current = solutionPath[solutionPath.length - 1];
          current.solveHighlight();
          changedCells.push(current); // Add cell to changed cells
          if (current === endCell) {
            setTimeout(() => {
              initializeMaze();
              solving = false;
            }, 1000);
          } else {
            let next = current.checkSolveNeighbors();
            if (next) {
              next.solve();
            } else {
              solutionPath.pop();
            }
          }
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        cols = floor(width / w);
        rows = floor(height / w);
        initializeMaze();
      }

      function doubleClicked() {
        let fs = fullscreen();
        fullscreen(!fs);
      }

      function initializeMaze() {
        grid = [];
        stack = [];
        solutionPath = [];
        changedCells = [];
        visitCount = 0;
        background(255);
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            let cell = new Cell(i, j);
            grid.push(cell);
          }
        }
        current = grid[0];
      }

      function Cell(i, j) {
        this.i = i;
        this.j = j;
        this.walls = [true, true, true, true];
        this.visited = false;
        this.solved = false;
        this.visitOrder = 0;
        this.assignedColor = null;

        this.checkNeighbors = function () {
          let neighbors = [];
          let top =
            j > 0 && !grid[index(i, j - 1)].visited
              ? grid[index(i, j - 1)]
              : undefined;
          let right =
            i < cols - 1 && !grid[index(i + 1, j)].visited
              ? grid[index(i + 1, j)]
              : undefined;
          let bottom =
            j < rows - 1 && !grid[index(i, j + 1)].visited
              ? grid[index(i, j + 1)]
              : undefined;
          let left =
            i > 0 && !grid[index(i - 1, j)].visited
              ? grid[index(i - 1, j)]
              : undefined;
          //let top = grid[index(i, j - 1)];
          //let right = grid[index(i + 1, j)];
          //let bottom = grid[index(i, j + 1)];
          //let left = grid[index(i - 1, j)];

          if (top) neighbors.push(top);
          if (right) neighbors.push(right);
          if (bottom) neighbors.push(bottom);
          if (left) neighbors.push(left);

          if (neighbors.length > 0) {
            let r = floor(random(0, neighbors.length));
            return neighbors[r];
          } else {
            return undefined;
          }
        };

        this.checkSolveNeighbors = function () {
          let neighbors = [];
          let top = grid[index(i, j - 1)];
          let right = grid[index(i + 1, j)];
          let bottom = grid[index(i, j + 1)];
          let left = grid[index(i - 1, j)];

          if (top && !top.solved && !this.walls[0]) {
            neighbors.push(top);
          }
          if (right && !right.solved && !this.walls[1]) {
            neighbors.push(right);
          }
          if (bottom && !bottom.solved && !this.walls[2]) {
            neighbors.push(bottom);
          }
          if (left && !left.solved && !this.walls[3]) {
            neighbors.push(left);
          }

          if (neighbors.length > 0) {
            let r = floor(random(0, neighbors.length));
            return neighbors[r];
          } else {
            return undefined;
          }
        };

        this.highlight = function () {
          let x = this.i * w;
          let y = this.j * w;
          fill(0, 0, 255, 100);
          rect(x, y, w, w);
        };

        this.solve = function () {
          this.solved = true;
          solutionPath.push(this);
        };

        this.solveHighlight = function () {
          let x = this.i * w;
          let y = this.j * w;
          noStroke();
          fill(255, 0, 0, 100);
          rect(x, y, w, w);
        };

        this.show = function () {
          let x = this.i * w;
          let y = this.j * w;

          // Fill the cell if it's visited or part of the solution
          if (this.visited || this.solved) {
            // let age = frameCount - this.firstVisitedFrame;
            // age = constrain(age, 0, 255); // Constrain age within 0 to 255
            // let alpha = map(age, 0, 255, 255, 0);
            // let visitColor = color(getColor(this.visitOrder));
            // visitColor.setAlpha(alpha);
            let idx = (changedCells.indexOf(this) || 0) + 1;
            let visitColor = getColorFromGradient(idx, changedCells.length);
            fill(visitColor);
            stroke(255, 255, 255, 0);
            rect(x, y, w, w);
          }

          // Draw walls over the filled cell
          stroke(0);
          if (this.walls[0]) {
            line(x, y, x + w, y); // Top wall
          }
          if (this.walls[1]) {
            line(x + w, y, x + w, y + w); // Right wall
          }
          if (this.walls[2]) {
            line(x + w, y + w, x, y + w); // Bottom wall
          }
          if (this.walls[3]) {
            line(x, y + w, x, y); // Left wall
          }
        };
      }

      function getColorFromGradient(num, n) {
        if (num < 1 || num > n) return null;

        let startColor = color(255, 255, 255); // White
        let endColor = color(128, 0, 128); // Vibrant Purple

        let amt = map(num, 1, n, 0, 1);

        return lerpColor(startColor, endColor, amt);
      }

      let baseColors = ["#264653", "#2A9D8F", "#E9C46A", "#F4A261", "#E76F51"];
      function getColor(order) {
        let colorIndex = floor(map(order, 0, visitCount, 0, baseColors.length));
        colorIndex = constrain(colorIndex, 0, baseColors.length - 1);
        return color(baseColors[colorIndex]);
      }

      function removeWalls(a, b) {
        let x = a.i - b.i;
        if (x === 1) {
          a.walls[3] = false; // Left wall of a
          b.walls[1] = false; // Right wall of b
        } else if (x === -1) {
          a.walls[1] = false; // Right wall of a
          b.walls[3] = false; // Left wall of b
        }
        let y = a.j - b.j;
        if (y === 1) {
          a.walls[0] = false; // Top wall of a
          b.walls[2] = false; // Bottom wall of b
        } else if (y === -1) {
          a.walls[2] = false; // Bottom wall of a
          b.walls[0] = false; // Top wall of b
        }
        //console.log("After removal, a.walls:", a.walls, "b.walls:", b.walls);
      }

      function index(i, j) {
        if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
          return -1;
        }
        return i + j * cols;
      }
    </script>
  </head>
  <body></body>
</html>
