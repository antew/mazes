<!DOCTYPE html>
<html>
  <head>
    <title>Maze Fun</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
    <style>
      body {
        text-align: center;
      }

      .open {
        display: block;
      }

      .closed {
        display: none;
      }
    </style>
    <script>
      let cols, rows;
      const w = 20;
      let grid = [];
      let current;
      let stack = [];
      let solving = false;
      let solutionPath = [];
      let startCell, endCell;
      let visitCount = 0;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        frameRate(30);
        cols = floor(width / w);
        rows = floor(height / w);
        initializeMaze();
      }

      function draw() {
        background(255);
        for (let i = 0; i < grid.length; i++) {
          grid[i].show();
        }

        if (!solving) {
          current.visited = true;
          current.visitOrder = visitCount++;
          current.highlight();
          let next = current.checkNeighbors();
          if (next) {
            next.visited = true;
            stack.push(current);
            removeWalls(current, next);
            current = next;
          } else if (stack.length > 0) {
            current = stack.pop();
          } else {
            solving = true;
            startCell = grid[0];
            endCell = grid[grid.length - 1];
            for (let i = 0; i < grid.length; i++) {
              grid[i].solved = false;
            }
            startCell.solve();
          }
        } else {
          if (solutionPath.length > 0) {
            let current = solutionPath[solutionPath.length - 1];
            current.solveHighlight();
            if (current === endCell) {
              setTimeout(() => {
                initializeMaze();
                solving = false;
              }, 1000);
            } else {
              let next = current.checkSolveNeighbors();
              if (next) {
                next.solve();
              } else {
                solutionPath.pop();
              }
            }
          }
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        cols = floor(width / w);
        rows = floor(height / w);
        initializeMaze();
      }

      function doubleClicked() {
        let fs = fullscreen();
        fullscreen(!fs);
      }

      function initializeMaze() {
        grid = [];
        stack = [];
        solutionPath = [];
        visitCount = 0;
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            let cell = new Cell(i, j);
            grid.push(cell);
          }
        }
        current = grid[0];
      }

      function Cell(i, j) {
        this.i = i;
        this.j = j;
        this.walls = [true, true, true, true];
        this.visited = false;
        this.solved = false;
        this.visitOrder = 0;
        this.assignedColor = null;
        this.firstVisitedFrame = -1;

        this.checkNeighbors = function () {
          let neighbors = [];
          let top = grid[index(i, j - 1)];
          let right = grid[index(i + 1, j)];
          let bottom = grid[index(i, j + 1)];
          let left = grid[index(i - 1, j)];

          if (top && !top.visited) {
            neighbors.push(top);
          }
          if (right && !right.visited) {
            neighbors.push(right);
          }
          if (bottom && !bottom.visited) {
            neighbors.push(bottom);
          }
          if (left && !left.visited) {
            neighbors.push(left);
          }

          if (neighbors.length > 0) {
            let r = floor(random(0, neighbors.length));
            return neighbors[r];
          } else {
            return undefined;
          }
        };

        this.checkSolveNeighbors = function () {
          let neighbors = [];
          let top = grid[index(i, j - 1)];
          let right = grid[index(i + 1, j)];
          let bottom = grid[index(i, j + 1)];
          let left = grid[index(i - 1, j)];

          if (top && !top.solved && !this.walls[0]) {
            neighbors.push(top);
          }
          if (right && !right.solved && !this.walls[1]) {
            neighbors.push(right);
          }
          if (bottom && !bottom.solved && !this.walls[2]) {
            neighbors.push(bottom);
          }
          if (left && !left.solved && !this.walls[3]) {
            neighbors.push(left);
          }

          if (neighbors.length > 0) {
            let r = floor(random(0, neighbors.length));
            return neighbors[r];
          } else {
            return undefined;
          }
        };

        this.highlight = function () {
          let x = this.i * w;
          let y = this.j * w;
          noStroke();
          fill(0, 0, 255, 100);
          rect(x, y, w, w);
        };

        this.solve = function () {
          this.solved = true;
          solutionPath.push(this);
        };

        this.solveHighlight = function () {
          let x = this.i * w;
          let y = this.j * w;
          noStroke();
          fill(255, 0, 0, 100);
          rect(x, y, w, w);
        };

        this.show = function () {
          let x = this.i * w;
          let y = this.j * w;

          // Fill the cell if it's visited or part of the solution
          if (this.visited || this.solved) {
            if (this.firstVisitedFrame === -1) {
              this.firstVisitedFrame = frameCount;
            }
            let age = frameCount - this.firstVisitedFrame;
            age = constrain(age, 0, 255); // Constrain age within 0 to 255
            let alpha = map(age, 0, 255, 255, 0);
            let visitColor = color(getColor(this.visitOrder));
            visitColor.setAlpha(alpha);
            fill(visitColor);
            stroke(255, 255, 255, 0);
            rect(x, y, w, w);
          }

          // Draw walls over the filled cell
          stroke(0);
          if (this.walls[0]) {
            line(x, y, x + w, y); // Top wall
          }
          if (this.walls[1]) {
            line(x + w, y, x + w, y + w); // Right wall
          }
          if (this.walls[2]) {
            line(x + w, y + w, x, y + w); // Bottom wall
          }
          if (this.walls[3]) {
            line(x, y + w, x, y); // Left wall
          }
        };
      }

      let baseColors = ["#264653", "#2A9D8F", "#E9C46A", "#F4A261", "#E76F51"];
      function getColor(order) {
        let colorIndex = floor(map(order, 0, visitCount, 0, baseColors.length));
        colorIndex = constrain(colorIndex, 0, baseColors.length - 1);
        return color(baseColors[colorIndex]);
      }

      function removeWalls(a, b) {
        let x = a.i - b.i;
        if (x === 1) {
          a.walls[3] = false; // Left wall of a
          b.walls[1] = false; // Right wall of b
        } else if (x === -1) {
          a.walls[1] = false; // Right wall of a
          b.walls[3] = false; // Left wall of b
        }
        let y = a.j - b.j;
        if (y === 1) {
          a.walls[0] = false; // Top wall of a
          b.walls[2] = false; // Bottom wall of b
        } else if (y === -1) {
          a.walls[2] = false; // Bottom wall of a
          b.walls[0] = false; // Top wall of b
        }
        console.log("After removal, a.walls:", a.walls, "b.walls:", b.walls);
      }

      function index(i, j) {
        if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
          return -1;
        }
        return i + j * cols;
      }
    </script>
  </head>
  <body></body>
</html>
